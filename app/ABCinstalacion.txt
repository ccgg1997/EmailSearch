crear carpeta
dentro de carpeta go init mod "ruta unica" (crear go.sum y go.mod)
luego en la carpeta raiz crear archivo go.work (donde se apunte a la carpeta de laapp, eje: "go 1.21.0
    use ./app" )

http://localhost:6061/debug/pprof/ para acceder al profiling
actualizar go mod tidy   

"comandos de teclado"
||

***************go help *****************

gofmt -w . (formato a todo)
go test -v ./...

//cuando se hacen cambios en el docker file pero se quiere recontruir
"docker-compose up --build"

//modulos
go mod init
go mod tidy (agregar e instalar modulos)

//generar los path de la documentacion de swagger cuando no estan en el main y las funciones estan en otra parte
swag init -g ../../cmd/main/main.go -o ../../docs


generar el profilling: 
go tool pprof cpu.pprof

funcion para crear un email:
// @Summary      Index in zincsearch
// @Description  Store an email entry (It´s an example to add a new email value).
// @Tags         Email
// @Accept       json
// @Produce      json
// @Param        emailData   body    EmailData    true   "Email parameters"
// @Success      200 {object} SuccessResponse
// @Router       /email [post]
func (eh *EmailHandler) CreateEmailHandler(w http.ResponseWriter, r *http.Request) {
	var cmd models.CreateEmailCMD
	if err := json.NewDecoder(r.Body).Decode(&cmd); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	email, err := eh.emailUsecase.CreateAndStoreEmail(&cmd)
	if err != nil {
		http.Error(w, "Error, formato invalido del body", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(map[string]interface{}{"creado con éxito": email})
}